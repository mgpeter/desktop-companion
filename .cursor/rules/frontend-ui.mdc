---
description: Frontend UI Rules
globs: ServoSkull.Web/**/*.{razor,css,js,cs}
---
# Frontend UI Rules

Rules for maintaining Blazor frontend standards in ServoSkull.NET.

<rule>
name: frontend_ui
description: Enforces Blazor component and UI standards for .NET 9
filters:
  - type: file_extension
    pattern: "\\.(razor|css|js)$"
  - type: content
    pattern: "@page|@component|@inject|@code|@rendermode"
  - type: event
    pattern: "file_create|file_modify"

actions:
  - type: reject
    conditions:
      - pattern: "@inject \\w+ \\w+"
        message: "Use constructor injection for components in .NET 9"
      - pattern: "StateHasChanged\\(\\)"
        message: "Use proper state management instead of direct calls"
      - pattern: "JSRuntime\\.InvokeAsync"
        message: "Use IJSRuntime through proper service abstraction"
      - pattern: "@page.*[^@rendermode]"
        message: "Specify render mode for page components"

  - type: suggest
    message: |
      Frontend UI Standards for .NET 9 Blazor:

      1. Render Modes:
         - Use @rendermode directive for all pages
         - Options: InteractiveServer, InteractiveWebAssembly, InteractiveAuto, or Static
         - Default to InteractiveAuto unless specific needs
         - Example:
           ```razor
           @page "/counter"
           @rendermode InteractiveAuto
           ```

      2. Component Organization:
         ```
         ServoSkull.WebApp/
         ├── Components/
         │   ├── Layout/              # Layout components
         │   ├── Shared/              # Reusable components
         │   └── Features/            # Feature-specific components
         ├── Pages/                   # Page components
         └── Services/                # Frontend services
         ```

      3. Component Standards:
         - Use constructor injection (new in .NET 9)
         - Implement IDisposable when needed
         - Use proper lifecycle methods
         - Follow single responsibility
         - Use proper parameter binding
         - Check RenderMode with @RenderInfo when needed

      4. State Management:
         - Use proper state containers
         - Implement proper event handling
         - Use cascading parameters when appropriate
         - Handle component disposal
         - Use new state persistence APIs for enhanced navigation
         - Properly handle prerender to interactive state

      5. Performance:
         - Use static rendering for non-interactive content
         - Leverage auto render mode for optimal performance
         - Use proper caching strategies
         - Implement proper error boundaries
         - Use WebSocket compression for Server mode
         - Leverage static asset optimization

      6. Authentication:
         - Use Microsoft Identity Platform for auth
         - Force static rendering for auth pages that need cookies
         - Handle auth state properly across render modes

examples:
  - input: |
      // Bad: No render mode specified
      @page "/counter"
      
      // Good: Using render mode
      @page "/counter"
      @rendermode InteractiveAuto
      
      public class Counter
      {
          private readonly ILogger<Counter> _logger;
          
          // Good: Constructor injection
          public Counter(ILogger<Counter> logger)
          {
              _logger = logger;
          }
      }
    output: "Correctly implemented .NET 9 component"

  - input: |
      // Bad: Old state management
      @code {
          private void UpdateState() {
              StateHasChanged();
          }
      }

      // Good: Modern state management
      @code {
          private readonly IState<CounterState> _state;
          
          public Counter(IState<CounterState> state)
          {
              _state = state;
          }
          
          private async Task UpdateStateAsync()
          {
              await _state.UpdateAsync(s => s with { Count = s.Count + 1 });
          }
      }
    output: "Correctly implemented state management"

metadata:
  priority: high
  version: 1.0
</rule> 